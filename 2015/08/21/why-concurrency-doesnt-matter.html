<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <meta name="viewport" content="width=device-width,initial-scale=1"> <link rel="shortcut icon" href="/static/img/favicon.ico"> <title>Why Concurrency doesn't Matter - Jerome Rasky</title> <meta name="author" content="Jerome Rasky"> <meta name="description" content="Why Concurrency doesn't Matter"> <meta name="keywords" content="Why Concurrency doesn't Matter, Jerome Rasky, "> <meta content="" property="fb:app_id"> <meta content="Jerome Rasky" property="og:site_name"> <meta content="Why Concurrency doesn't Matter" property="og:title"> <meta content="article" property="og:type"> <meta content="Personal Website" property="og:description"> <meta content="http://rasky.co//2015/08/21/why-concurrency-doesnt-matter.html" property="og:url"> <meta content="2015-08-21T00:00:00-07:00" property="article:published_time"> <meta content="http://rasky.co//about/" property="article:author"> <meta content="http://rasky.co//static/img/logo-high-resolution.png" property="og:image"> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@"> <meta name="twitter:creator" content="@"> <meta name="twitter:title" content="Why Concurrency doesn't Matter"> <meta name="twitter:url" content="http://rasky.co//2015/08/21/why-concurrency-doesnt-matter.html"> <meta name="twitter:description" content="Personal Website"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"> <!-- Bootstrap --> <link rel="stylesheet" href="/external/bootstrap/dist/css/bootstrap.min.css"> <!-- Bootstrap Material Design --> <link rel="stylesheet" href="/external/bootstrap-material-design/dist/css/bootstrap-material-design.min.css"> <!-- FontAwesome --> <link rel="stylesheet" href="/external/font-awesome/css/font-awesome.min.css"> <!-- Roboto Font Face --> <link rel="stylesheet" href="/external/roboto-fontface/css/roboto/roboto-fontface.css"> <!-- Site CSS --> <link rel="stylesheet" href="/static/css/main.css"> <link rel="stylesheet" href="/static/css/projects.css"> <link rel="stylesheet" href="/static/css/syntax.css"> </head> <body class="home overflow-hidden"> <div class="header-panel shadow-z-2"> <div class="container"> <div class="row"> <div class="col-md-3 col-sm-4 col-xs-12"> <div class="row-picture"> <img id="about" class="logo-img" src="/static/img/avatar.jpg" height="75px" width="75px"> </div> <div class="row-details"> <h4 class="list-group-item-heading">Jerome Rasky</h4> <p class="list-group-item-text">Software Engineer</p> </div> <div class="navbar-header pull-right"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> <span class="sr-only">Toggle navigation</span> <i class="fa fa-2x fa-bars"></i> </button> </div> </div> <div class="col-md-9 col-sm-8 col-xs-12"> <h2 class="blog-title-pro">Why Concurrency doesn't Matter</h2> <p class="info"> <span class="time">21 Aug 2015</span> </p> </div> </div> </div> </div> <div class="container main outer"> <div class="row"> <div class="col-lg-3 col-md-4 col-xs-12"> <nav class="menu"> <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"> <ul class="list-separator nav navbar-nav well well-primary post"> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 current-menu-item why-concurrency-doesnt-matter.html"><a href="/" target="_self"><i class="fa fa-home"></i> Home</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 why-concurrency-doesnt-matter.html"><a href="/about/" target="_self"><i class="fa fa-comments"></i> About</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 why-concurrency-doesnt-matter.html"><a href="/projects" target="_self"><i class="fa fa-desktop"></i> Projects</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 why-concurrency-doesnt-matter.html"><a href="/resume.pdf" target="_blank"><i class="fa fa-graduation-cap"></i> Resume</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 why-concurrency-doesnt-matter.html"><a href="https://github.com/jrasky" target="_blank"><i class="fa fa-github"></i> Github</a></li> </ul> </div> </nav> </div> <div class="col-lg-9 col-md-8 col-xs-12 full"> <div class="post-content well"> <article class="content"> <div class="post"><p>Or, why I like Rust</p> <p>There’s a lot of talk these days about how important concurrency is. The reasons are obvious: in a world of computing at scale, single processors don’t. Many people decry the death of Moore’s law, and increasingly they seem to be right. Transistors can only get so small, after all. As a result, the constantly increasing desire for computer performance will have to come from concurrency, working around the issue of Moore’s law entirely. All of this is sound reasoning.</p> <p>Most older languages were designed in a world where Moore’s law was still very valid, and where compute performance came from single processors, not farms of them. Concurrency and scale networks existed, but were largely restricted to scientific computing or very special edge-cases, and the technologies that came out of them were not generally useful. Those days were great. However, that world doesn’t exist anymore, and instead the lessons being drawn from the current flock of “giants” is the importance of scale. The future is now, and it looks like networks.</p> <p>As a result, these older languages did not serve the concurrency story very well. Though concurrency primitives existed in those languages, they usually require careful thought and planning for effective use. Data races abound, memory corruption is easy. In general, it’s not the most inviting environment. In reaction to this, certain modern languages tout “concurrency support” as a major feature. The goal: to be rid of the pitfalls of traditional concurrency, and instead present a sane, easy-to-use interface that falls neatly in with all the other traditional paradigms of programming everybody is used to. Truly a noble cause.</p> <p>The problem lies here: concurrency is an anti-pattern to the traditional programming paradigms. Computing takes a certain level of discipline, especially with non-managed languages. Concurrency makes everything much harder, requiring either a much higher degree of discipline or a much higher degree of management. The latter group includes languages like Haskell, which are generally much more declarative. What you lose in terms of control over your code, however, you gain in performance. Suddenly, all the traditional problems with concurrency go away, and you’re left with something concurrent and safe. This is awesome, except that you lose many of the traditional paradigms most programmers are used to. It’s great for a wide variety of problems that benefit greatly from concurrency, but it’s also hard to get used to, and not great for an equally large number of corner cases in more traditional programming where a certain level of concurrency plays positively to the application. Not only this, but learning this style requires a lot of domain-specific work and knowledge. This doesn’t sound like the best solution.</p> <p>What certain modern languages offer does sound like a great solution: sane concurrency without any of the micro-management baggage. It’s a great promise, but one that’s ultimately contradictory. These modern languages do provide great front-ends to the concurrency primitives everybody loves to hate. If your greatest worry is about correctly creating or scheduling threads, or scaling to tens of thousands of threads, or about correctly cleaning up a thread’s resources when it finishes, then these new languages offer exactly what you’re after.</p> <p>That’s not really the–or, at least, my–greatest concern with threads. Obviously, resource management and scale are an issue, but those are whenever I’m doing any programming. They’re amplified by threads, but they aren’t fundamentally <em>new</em> worries. The new worries I do have relate to data races. Threading means giving up a huge amount of control over how your code executes, which means any interactions different parts of your code have are now much less predictable. The easy way to get out of this trap is to prevent all interactions, but that precludes any real benefits that concurrency provides. If all concurrent tasks are completely independent, then they cannot service the same problem.</p> <p>Using concurrency to work on a single problem requires sharing certain resources, even if those resources are simply messages. That shared state means data races are possible. Data races are an entirely different class of worries from what’s possible in traditional, single-threaded programming. These concerns are serviced by the micro-management model, but not by the sexy-interface model employed by certain modern languages. As a result, these new languages do not really solve any underlying problems, but instead lather on a fresh layer of paint. On a small scale, everything feels awesome. On a larger scale, all the same problems come back.</p> <p>This is why concurrency doesn’t matter. It doesn’t because the real problems concurrency causes aren’t addressed by modern languages. Certain other, more declarative languages address them to a certain degree, but are “weird” enough to not be generally useful. Or, if they are, they haven’t seen very much adoption.</p> <p>What about the resource management and scaling category of problems, however? Although they are fairly general, they are definitely amplified by concurrency. The traditional answer to resource management has been garbage collection, which is a good solution, but doesn’t <em>always</em> scale very well. Not only this, but resource management incurs a performance penalty, caused by the garbage collection itself and by the extra work required when acquiring or releasing resources. Much like the micro-management model for concurrency, this doesn’t seem like the best solution.</p> <p>This is where Rust comes in. Rust’s major innovation is the borrow checker, an additional bit of information the compiler tracks which enables it to determine when data comes into and falls out of scope. This means the compiler can identify in a deterministic fashion when to free resources, meaning it can insert this information into the binary it produces. No more need for separate garbage collection, instead resources are freed at the ends of certain lexical scopes. This can obviously hurt performance–especially when code is written such that large amounts of data are copied and freed–but this is always the case when the language does not micro-manage your code.</p> <p>What isn’t always the case is the level of control that a borrow checker gives you. Even if the worst case isn’t very different from a garbage collector, the average case is much better. All the resources your program uses are right there, instead of being hidden away behind a garbage collector. Plus, the behavior is defined by the lexical scope of your code, and not by some black-box mechanics taking place behind the scenes of the garbage collector.</p> <p>All of this makes for a mechanic that I think will survive Rust as a language. The borrow checker is something extremely useful in general programming, not only because it manages resources with no overhead, but because it also prevents many classes of memory corruption issues and data races often present in other languages. Much like type checking before it, I think borrow checking will become part of future languages and we’ll all wonder how we ever dealt with programming without it.</p> </div> </article> <hr> <div class="PageNavigation"> <a class="prev" href="/2015/03/09/the-new-macbook.html">&laquo; The New MacBook</a> <a class="next" href="/2017/06/09/android-performance.html">Android Performance &raquo;</a> </div> </div> <div class="row"> <div class="col-md-12 col-xs-12 footer"> <footer> © 2017 Jerome Rasky and others, provided under the <a href="/LICENSE.txt" target="_blank">MIT</a> license. </footer> </div> </div> </div> <!-- end /.col-md-9 --> </div> <!-- end /.row --> </div> <!-- jquery --> <script src="/external/jquery/dist/jquery.min.js"></script> <!-- Bootstrap --> <script src="/external/bootstrap/dist/js/bootstrap.min.js"></script> <!-- Bootstrap Material Design --> <script src="/external/bootstrap-material-design/dist/js/material.min.js"></script> </body> </html> 