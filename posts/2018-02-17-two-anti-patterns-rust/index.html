<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Two anti-patterns in Rust - Jerome Rasky</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Two anti-patterns in Rust" />
<meta property="og:description" content="I had an interesting conversation with a friend today about programming languages. in particular, we talked about Rust, which my friend had recently used to do a small personal project. We talked about what matters in languages, and how companies and people choose the languages that they do.
I&rsquo;m a huge fan of Rust. I think it solves the data sharing problem, which is a domain that&rsquo;s traditionally been the realm of functional languages." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jrasky.github.io/posts/2018-02-17-two-anti-patterns-rust/" />
<meta property="article:published_time" content="2018-02-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-02-17T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Two anti-patterns in Rust"/>
<meta name="twitter:description" content="I had an interesting conversation with a friend today about programming languages. in particular, we talked about Rust, which my friend had recently used to do a small personal project. We talked about what matters in languages, and how companies and people choose the languages that they do.
I&rsquo;m a huge fan of Rust. I think it solves the data sharing problem, which is a domain that&rsquo;s traditionally been the realm of functional languages."/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://jrasky.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://jrasky.github.io/css/main.css" /><script src="https://jrasky.github.io/js/feather.min.js"></script><script src="https://jrasky.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title">Jerome Rasky</h1>
	<div class="site-description"><h2>Software Engineer</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/jrasky" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/resume.pdf">Resume</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">Two anti-patterns in Rust</h1>
			<div class="meta">Posted at &mdash; Feb 17, 2018</div>
		</div>

		<div class="markdown">
			<p>I had an interesting conversation with a friend today about programming
languages. in particular, we talked about Rust, which my friend had recently
used to do a small personal project. We talked about what matters in languages,
and how companies and people choose the languages that they do.</p>

<p>I&rsquo;m a huge fan of Rust. I think it solves the data sharing problem, which is a
domain that&rsquo;s traditionally been the realm of functional languages. Those
languages have their merits, but it turns out that humans tend not to think the
way that functional languages work.</p>

<p>At one point, my friend got into two issues he ran into with Rust, which he felt
frustrated about, and which made him feel like the language really wasn&rsquo;t ready
for prime time. I understand how he feels, because one of the hardest things to
do when learning a language is to figure out why the language is built a certain
way. I know that I get frustrated at Go sometimes for reasons that feel similar.</p>

<p>The first anti-pattern my friend came across he called &ldquo;partial borrows,&rdquo; which
more concretely is the issue around how member functions that take pointers to
<code>self</code> borrow the whole struct. Functionally, what he wants to do is write an
algorithm as member functions on one data structure that reference different
parts of the struct, and then compose calls to those methods to form an
algorithm. An example would be a method that produces a reference to some data
item, which is used to decide on what kind of mutation to do.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#00f">impl</span> Algo {
    <span style="color:#00f">fn</span> get_item(&amp;self, key: String) -&gt; <span style="color:#00f">&amp;</span><span style="color:#2b91af">DataItem</span> {
        <span style="color:#008000">// Produce a reference to a data item
</span><span style="color:#008000"></span>    }

    <span style="color:#00f">fn</span> update_accumulator(&amp;<span style="color:#00f">mut</span> self, item: <span style="color:#00f">&amp;</span><span style="color:#2b91af">DataItem</span>) {
        <span style="color:#008000">// Update the accumulator with the data item
</span><span style="color:#008000"></span>    }

    <span style="color:#00f">fn</span> do_work(&amp;<span style="color:#00f">mut</span> self) {
        <span style="color:#00f">let</span> item = self.get_item(<span style="color:#a31515">&#34;data_key&#34;</span>);

        <span style="color:#008000">// Will not compile!
</span><span style="color:#008000"></span>        self.update_accumulator(item);
    }
}
</code></pre></div>
<p>My sense about the matter is that the above code has a code smell, namely that
of a large struct. In a way, Rust is trying to tell you that accumulators and
data stores should be separate from each other. When you borrow from <code>self</code>,
that borrow effectively depends on the entire state of your struct. In other
languages, you&rsquo;d have a new invariant: don&rsquo;t break the borrowed item while
updating the accumulator. In Rust, the compiler steps in because it can&rsquo;t prove
that your methods have those invariants.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#00f">struct</span> <span style="color:#2b91af">Algo</span> {
    data_items: <span style="color:#2b91af">DataStore</span>,
    accum: <span style="color:#2b91af">Accumulator</span>,
}

<span style="color:#00f">impl</span> Algo {
    <span style="color:#00f">fn</span> do_work(&amp;<span style="color:#00f">mut</span> self) {
        <span style="color:#00f">let</span> item = self.data_items.get_item(<span style="color:#a31515">&#34;data_key&#34;</span>);

        <span style="color:#008000">// Will compile happily
</span><span style="color:#008000"></span>        self.accum.update(item);
    }
}
</code></pre></div>
<p>It might not be readily obvious how the above code is really any different. All
I&rsquo;ve done is to re-arrange how the data is organized, and the pattern of calls.
In most languages, this would be largely identical, since most languages let you
alias mutable data.</p>

<p>By splitting your data into pieces, and borrowing each piece separately, Rust
can prove that the two borrows can&rsquo;t interfere with each other. There have been
discussions about this issue in Rust, and how it would be great to have some way
to express those invariants in the type system, in a way merging the semantics
of other languages to a point into Rust. Maybe that&rsquo;s the right direction.</p>

<p>The second anti-pattern my friend tried to implement was that of out parameters.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#00f">fn</span> do_work(buffer: <span style="color:#00f">&amp;</span><span style="color:#2b91af">mut</span> Vec&lt;<span style="color:#2b91af">usize</span>&gt;) {
    <span style="color:#008000">// Do some work and mutate 
</span><span style="color:#008000"></span>}
</code></pre></div>
<p>In imperative languages without move semantics, this kind of pattern can be
somewhat essential. By passing in a reference to a vector, you avoid copying all
the values. Unfortunately in Rust, out parameters play poorly with the borrow
checker. One out parameter is generally alright, but if you start to have more
than one out parameter, you can get some very bad interactions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#00f">struct</span> <span style="color:#2b91af">Algo</span> {
    param: <span style="color:#2b91af">usize</span>,
    inner_buffer: Vec&lt;<span style="color:#2b91af">usize</span>&gt;
}

<span style="color:#00f">impl</span> Algo {
    <span style="color:#00f">fn</span> do_work(&amp;self, buffer: <span style="color:#00f">&amp;</span><span style="color:#2b91af">mut</span> Vec&lt;<span style="color:#2b91af">usize</span>&gt;) {
        <span style="color:#008000">// Do some work and mutate buffer, using information from self
</span><span style="color:#008000"></span>    }

    <span style="color:#00f">fn</span> process(&amp;<span style="color:#00f">mut</span> self) {
        <span style="color:#008000">// Will not compile!
</span><span style="color:#008000"></span>        self.do_work(&amp;<span style="color:#00f">mut</span> self.inner_buffer);
    }
}
</code></pre></div>
<p>This is almost a combination of the first anti-pattern, but it&rsquo;s more of a case
of out parameters. With imperative programming, it&rsquo;s normal to destructively
update some object with information, and then eventually process its internal
state into some kind of output. This won&rsquo;t work, however, since the update
method takes self as a reference: if the above could compile, self would alias
buffer, and that breaks invariants in Rust.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#00f">struct</span> <span style="color:#2b91af">Algo</span> {
    param: <span style="color:#2b91af">usize</span>,
    data: <span style="color:#2b91af">AlgoData</span>
}

<span style="color:#00f">struct</span> <span style="color:#2b91af">AlgoData</span> {
    inner_buffer: Vec&lt;<span style="color:#2b91af">usize</span>&gt;
}

<span style="color:#00f">impl</span> AlgoData {
    <span style="color:#00f">fn</span> do_work(&amp;<span style="color:#00f">mut</span> self, param: <span style="color:#2b91af">usize</span>) {
        <span style="color:#008000">// Do work using param
</span><span style="color:#008000"></span>    }
}

<span style="color:#00f">impl</span> Algo {
    <span style="color:#00f">fn</span> process(&amp;<span style="color:#00f">mut</span> self) {
        self.data.do_work(self.param);
    }
}
</code></pre></div>
<p>The solution in this case is to split the data structure. When you see an out
parameter in Rust, what you really want is a separate object, which has its own
methods. By doing this, you can narrow the borrow down to just the field of Algo
that you want to update.</p>

<p>There&rsquo;s a common theme in these two problems, which is that of overly broad
borrowing. In rust, <code>&amp;mut self</code> really means you are borrowing the whole struct.
An important question you should ask yourself is what the scope of the different
references really means in your code. If you&rsquo;re borrowing <code>&amp;mut self</code>, that
means the entire data structure, when what you probably want is to only borrow
part of the data structure.</p>

		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = '';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div><a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
