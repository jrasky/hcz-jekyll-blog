<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <meta name="viewport" content="width=device-width,initial-scale=1"> <link rel="shortcut icon" href="/static/img/favicon.ico"> <title>Two anti-patterns in Rust - Jerome Rasky</title> <meta name="author" content="Jerome Rasky"> <meta name="description" content="Two anti-patterns in Rust"> <meta name="keywords" content="Two anti-patterns in Rust, Jerome Rasky, "> <meta content="" property="fb:app_id"> <meta content="Jerome Rasky" property="og:site_name"> <meta content="Two anti-patterns in Rust" property="og:title"> <meta content="article" property="og:type"> <meta content="Personal Website" property="og:description"> <meta content="http://rasky.co//2018/02/17/two-anti-patterns-rust.html" property="og:url"> <meta content="2018-02-17T00:00:00-08:00" property="article:published_time"> <meta content="http://rasky.co//about/" property="article:author"> <meta content="http://rasky.co//static/img/logo-high-resolution.png" property="og:image"> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@"> <meta name="twitter:creator" content="@"> <meta name="twitter:title" content="Two anti-patterns in Rust"> <meta name="twitter:url" content="http://rasky.co//2018/02/17/two-anti-patterns-rust.html"> <meta name="twitter:description" content="Personal Website"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"> <!-- Bootstrap --> <link rel="stylesheet" href="/external/bootstrap/dist/css/bootstrap.min.css"> <!-- Bootstrap Material Design --> <link rel="stylesheet" href="/external/bootstrap-material-design/dist/css/bootstrap-material-design.min.css"> <!-- FontAwesome --> <link rel="stylesheet" href="/external/font-awesome/css/font-awesome.min.css"> <!-- Roboto Font Face --> <link rel="stylesheet" href="/external/roboto-fontface/css/roboto/roboto-fontface.css"> <!-- Site CSS --> <link rel="stylesheet" href="/static/css/main.css"> <link rel="stylesheet" href="/static/css/projects.css"> <link rel="stylesheet" href="/static/css/syntax.css"> </head> <body class="home overflow-hidden"> <div class="header-panel shadow-z-2"> <div class="container"> <div class="row"> <div class="col-md-3 col-sm-4 col-xs-12"> <div class="row-picture"> <img id="about" class="logo-img" src="/static/img/avatar.jpg" height="75px" width="75px"> </div> <div class="row-details"> <h4 class="list-group-item-heading">Jerome Rasky</h4> <p class="list-group-item-text">Software Engineer</p> </div> <div class="navbar-header pull-right"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> <span class="sr-only">Toggle navigation</span> <i class="fa fa-2x fa-bars"></i> </button> </div> </div> <div class="col-md-9 col-sm-8 col-xs-12"> <h2 class="blog-title-pro">Two anti-patterns in Rust</h2> <p class="info"> <span class="time">17 Feb 2018</span> </p> </div> </div> </div> </div> <div class="container main outer"> <div class="row"> <div class="col-lg-3 col-md-4 col-xs-12"> <nav class="menu"> <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"> <ul class="list-separator nav navbar-nav well well-primary post"> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 current-menu-item two-anti-patterns-rust.html"><a href="/" target="_self"><i class="fa fa-home"></i> Home</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 two-anti-patterns-rust.html"><a href="/about/" target="_self"><i class="fa fa-comments"></i> About</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 two-anti-patterns-rust.html"><a href="/projects" target="_self"><i class="fa fa-desktop"></i> Projects</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 two-anti-patterns-rust.html"><a href="/resume.pdf" target="_blank"><i class="fa fa-graduation-cap"></i> Resume</a></li> <li class="col-lg-12 col-md-12 col-sm-4 col-xs-12 two-anti-patterns-rust.html"><a href="https://github.com/jrasky" target="_blank"><i class="fa fa-github"></i> Github</a></li> </ul> </div> </nav> </div> <div class="col-lg-9 col-md-8 col-xs-12 full"> <div class="post-content well"> <article class="content"> <div class="post"><p>I had an interesting conversation with a friend today about programming languages. in particular, we talked about Rust, which my friend had recently used to do a small personal project. We talked about what matters in languages, and how companies and people choose the languages that they do.</p> <p>I’m a huge fan of Rust. I think it solves the data sharing problem, which is a domain that’s traditionally been the realm of functional languages. Those languages have their merits, but it turns out that humans tend not to think the way that functional languages work.</p> <p>At one point, my friend got into two issues he ran into with Rust, which he felt frustrated about, and which made him feel like the language really wasn’t ready for prime time. I understand how he feels, because one of the hardest things to do when learning a language is to figure out why the language is built a certain way. I know that I get frustrated at Go sometimes for reasons that feel similar.</p> <p>The first anti-pattern my friend came across he called “partial borrows,” which more concretely is the issue around how member functions that take pointers to <code class="highlighter-rouge">self</code> borrow the whole struct. Functionally, what he wants to do is write an algorithm as member functions on one data structure that reference different parts of the struct, and then compose calls to those methods to form an algorithm. An example would be a method that produces a reference to some data item, which is used to decide on what kind of mutation to do.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">DataItem</span> <span class="p">{</span>
        <span class="c">// Produce a reference to a data item</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update_accumulator</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">DataItem</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Update the accumulator with the data item</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">do_work</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_item</span><span class="p">(</span><span class="s">"data_key"</span><span class="p">);</span>

        <span class="c">// Will not compile!</span>
        <span class="k">self</span><span class="nf">.update_accumulator</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>My sense about the matter is that the above code has a code smell, namely that of a large struct. In a way, Rust is trying to tell you that accumulators and data stores should be separate from each other. When you borrow from <code class="highlighter-rouge">self</code>, that borrow effectively depends on the entire state of your struct. In other languages, you’d have a new invariant: don’t break the borrowed item while updating the accumulator. In Rust, the compiler steps in because it can’t prove that your methods have those invariants.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="n">data_items</span><span class="p">:</span> <span class="n">DataStore</span><span class="p">,</span>
    <span class="n">accum</span><span class="p">:</span> <span class="n">Accumulator</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">do_work</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data_items</span><span class="nf">.get_item</span><span class="p">(</span><span class="s">"data_key"</span><span class="p">);</span>

        <span class="c">// Will compile happily</span>
        <span class="k">self</span><span class="py">.accum</span><span class="nf">.update</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>It might not be readily obvious how the above code is really any different. All I’ve done is to re-arrange how the data is organized, and the pattern of calls. In most languages, this would be largely identical, since most languages let you alias mutable data.</p> <p>By splitting your data into pieces, and borrowing each piece separately, Rust can prove that the two borrows can’t interfere with each other. There have been discussions about this issue in Rust, and how it would be great to have some way to express those invariants in the type system, in a way merging the semantics of other languages to a point into Rust. Maybe that’s the right direction.</p> <p>The second anti-pattern my friend tried to implement was that of out parameters.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">do_work</span><span class="p">(</span><span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Do some work and mutate </span>
<span class="p">}</span>
</code></pre></div></div> <p>In imperative languages without move semantics, this kind of pattern can be somewhat essential. By passing in a reference to a vector, you avoid copying all the values. Unfortunately in Rust, out parameters play poorly with the borrow checker. One out parameter is generally alright, but if you start to have more than one out parameter, you can get some very bad interactions.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="n">param</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">inner_buffer</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">do_work</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Do some work and mutate buffer, using information from self</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Will not compile!</span>
        <span class="k">self</span><span class="nf">.do_work</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.inner_buffer</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is almost a combination of the first anti-pattern, but it’s more of a case of out parameters. With imperative programming, it’s normal to destructively update some object with information, and then eventually process its internal state into some kind of output. This won’t work, however, since the update method takes self as a reference: if the above could compile, self would alias buffer, and that breaks invariants in Rust.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="n">param</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">AlgoData</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">AlgoData</span> <span class="p">{</span>
    <span class="n">inner_buffer</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">AlgoData</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">do_work</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Do work using param</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Algo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.do_work</span><span class="p">(</span><span class="k">self</span><span class="py">.param</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The solution in this case is to split the data structure. When you see an out parameter in Rust, what you really want is a separate object, which has its own methods. By doing this, you can narrow the borrow down to just the field of Algo that you want to update.</p> <p>There’s a common theme in these two problems, which is that of overly broad borrowing. In rust, <code class="highlighter-rouge">&amp;mut self</code> really means you are borrowing the whole struct. An important question you should ask yourself is what the scope of the different references really means in your code. If you’re borrowing <code class="highlighter-rouge">&amp;mut self</code>, that means the entire data structure, when what you probably want is to only borrow part of the data structure.</p> </div> </article> <hr> <div class="PageNavigation"> <a class="prev" href="/2017/12/31/apple-ios-defaults.html">&laquo; Apple's Defaults System</a> </div> </div> <div class="row"> <div class="col-md-12 col-xs-12 footer"> <footer> © 2017 Jerome Rasky and others, provided under the <a href="/LICENSE.txt" target="_blank">MIT</a> license. </footer> </div> </div> </div> <!-- end /.col-md-9 --> </div> <!-- end /.row --> </div> <!-- jquery --> <script src="/external/jquery/dist/jquery.min.js"></script> <!-- Bootstrap --> <script src="/external/bootstrap/dist/js/bootstrap.min.js"></script> <!-- Bootstrap Material Design --> <script src="/external/bootstrap-material-design/dist/js/material.min.js"></script> </body> </html> 